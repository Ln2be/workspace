<!DOCTYPE html>
<html>
  <head>
    <title>Complete Segment Generator</title>
    <style>
      #svg {
        border: 1px solid #000;
      }
      button {
        margin: 10px;
        padding: 5px 15px;
      }
      .controls {
        margin: 10px;
      }
      .point:hover {
        cursor: move;
        filter: brightness(120%);
      }
      .point-label {
        font-family: Arial;
        font-size: 12px;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <button id="toggleMode">Switch to Line Mode</button>
      <button id="clearLast">Clear Last Segment</button>
      <button id="clearAll">Clear All</button>
      <label>Point Size: </label>
      <input type="range" id="pointSize" min="3" max="20" value="7" />
      <label>Label: </label>
      <input type="text" id="nextLabel" size="1" value="A" />
    </div>
    <svg id="svg" width="800" height="600"></svg>

    <script>
      class Point {
        constructor(x, y, label, size) {
          this.x = x;
          this.y = y;
          this.id = Date.now() + Math.random();
          this.label = label;
          this.size = size;
        }

        draw(svg) {
          const point = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          point.setAttribute("data-point-id", this.id);
          point.setAttribute("cx", this.x);
          point.setAttribute("cy", this.y);
          point.setAttribute("r", this.size);
          point.setAttribute(
            "fill",
            CanvasManager.currentMode === "arc" ? "red" : "green"
          );
          point.setAttribute("class", "point");

          const label = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          label.setAttribute("x", this.x + this.size + 2);
          label.setAttribute("y", this.y - this.size - 2);
          label.setAttribute("class", "point-label");
          label.textContent = this.label;

          svg.appendChild(point);
          svg.appendChild(label);
          return point;
        }

        distanceTo(x, y) {
          return Math.hypot(this.x - x, this.y - y);
        }

        constrainToCircle(circle, mouseX, mouseY) {
          const dx = mouseX - circle.cx;
          const dy = mouseY - circle.cy;
          const angle = Math.atan2(dy, dx);
          this.x = circle.cx + circle.radius * Math.cos(angle);
          this.y = circle.cy + circle.radius * Math.sin(angle);
        }
      }

      class Circle {
        constructor(cx, cy, radius) {
          this.cx = cx;
          this.cy = cy;
          this.radius = radius;
        }

        static fromThreePoints(A, B, C) {
          const D =
            2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
          if (D === 0) return null;

          const cx =
            ((A.x ** 2 + A.y ** 2) * (B.y - C.y) +
              (B.x ** 2 + B.y ** 2) * (C.y - A.y) +
              (C.x ** 2 + C.y ** 2) * (A.y - B.y)) /
            D;

          const cy =
            ((A.x ** 2 + A.y ** 2) * (C.x - B.x) +
              (B.x ** 2 + B.y ** 2) * (A.x - C.x) +
              (C.x ** 2 + C.y ** 2) * (B.x - A.x)) /
            D;

          return new Circle(cx, cy, Math.hypot(A.x - cx, A.y - cy));
        }

        drawCenter(svg, label) {
          const center = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          center.setAttribute("cx", this.cx);
          center.setAttribute("cy", this.cy);
          center.setAttribute("r", CanvasManager.POINT_RADIUS);
          center.setAttribute("fill", "blue");

          const centerLabel = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          centerLabel.setAttribute(
            "x",
            this.cx + CanvasManager.POINT_RADIUS + 2
          );
          centerLabel.setAttribute(
            "y",
            this.cy - CanvasManager.POINT_RADIUS - 2
          );
          centerLabel.textContent = "C" + label;

          svg.appendChild(center);
          svg.appendChild(centerLabel);
        }

        getAngle(point) {
          const dx = point.x - this.cx;
          const dy = point.y - this.cy;
          const angle = Math.atan2(dy, dx);
          return angle < 0 ? angle + 2 * Math.PI : angle;
        }
      }

      class Segment {
        constructor(type, points) {
          this.type = type;
          this.points = points;
          this.circle =
            type === "arc" ? Circle.fromThreePoints(...points) : null;
        }

        draw(svg) {
          if (this.type === "arc" && this.circle) {
            const [p1, p2, p3] = this.points;
            const path = this.createArcPath(p1, p2, p3);
            svg.appendChild(path);
            this.circle.drawCenter(svg, this.points[0].label);
          } else if (this.type === "line") {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            line.setAttribute("x1", this.points[0].x);
            line.setAttribute("y1", this.points[0].y);
            line.setAttribute("x2", this.points[1].x);
            line.setAttribute("y2", this.points[1].y);
            line.setAttribute("stroke", "green");
            line.setAttribute("stroke-width", "2");
            svg.appendChild(line);
          }
        }

        createArcPath(left, middle, right) {
          const thetaL = this.circle.getAngle(left);
          const thetaM = this.circle.getAngle(middle);
          const thetaR = this.circle.getAngle(right);

          const isClockwise =
            (thetaM - thetaL + 2 * Math.PI) % (2 * Math.PI) <=
            (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI);
          const sweepFlag = isClockwise ? 1 : 0;

          const angleDiff = sweepFlag
            ? (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI)
            : (thetaL - thetaR + 2 * Math.PI) % (2 * Math.PI);
          const largeArcFlag = angleDiff > Math.PI ? 1 : 0;

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute(
            "d",
            `M ${left.x},${left.y} ` +
              `A ${this.circle.radius} ${this.circle.radius} 0 ` +
              `${largeArcFlag} ${sweepFlag} ${right.x},${right.y}`
          );
          path.setAttribute("stroke", "blue");
          path.setAttribute("fill", "none");
          path.setAttribute("stroke-width", "2");
          return path;
        }
      }

      class CanvasManager {
        static POINT_RADIUS = 7;
        static SNAP_DISTANCE = 15;
        static currentMode = "arc";

        constructor() {
          this.svg = document.getElementById("svg");
          this.segments = [];
          this.tempPoints = [];
          this.allPoints = [];
          this.draggedPoint = null;
          this.offset = { x: 0, y: 0 };
          this.currentLabelCharCode = 65;

          this.setupEventListeners();
        }

        getMousePosition(event) {
          const rect = this.svg.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
        }

        getNextLabel() {
          const label = String.fromCharCode(this.currentLabelCharCode);
          this.currentLabelCharCode =
            this.currentLabelCharCode < 90 ? this.currentLabelCharCode + 1 : 65;
          return label;
        }

        findExistingPoint(x, y) {
          return this.allPoints.find(
            (p) => p.distanceTo(x, y) <= CanvasManager.SNAP_DISTANCE
          );
        }

        handleClick(event) {
          if (this.draggedPoint) return;

          const { x, y } = this.getMousePosition(event);
          const existing = this.findExistingPoint(x, y);
          const nextLabel = document.getElementById("nextLabel").value;

          const point =
            existing || new Point(x, y, nextLabel, CanvasManager.POINT_RADIUS);
          if (!existing) {
            this.allPoints.push(point);
            this.currentLabelCharCode = nextLabel.charCodeAt(0) + 1;
            if (this.currentLabelCharCode > 90) this.currentLabelCharCode = 65;
          }

          this.tempPoints.push(point);

          if (
            (CanvasManager.currentMode === "arc" &&
              this.tempPoints.length === 3) ||
            (CanvasManager.currentMode === "line" &&
              this.tempPoints.length === 2)
          ) {
            this.completeSegment();
          }

          this.redraw();
        }

        completeSegment() {
          const segment = new Segment(CanvasManager.currentMode, [
            ...this.tempPoints,
          ]);
          if (CanvasManager.currentMode === "arc" && !segment.circle) {
            alert("Points are collinear!");
          } else {
            this.segments.push(segment);
          }
          this.tempPoints = [];
        }

        startDrag(event) {
          const pointId = event.target.getAttribute("data-point-id");
          this.draggedPoint = this.allPoints.find((p) => p.id == pointId);
          if (!this.draggedPoint) return;

          const rect = this.svg.getBoundingClientRect();
          this.offset.x = event.clientX - rect.left - this.draggedPoint.x;
          this.offset.y = event.clientY - rect.top - this.draggedPoint.y;
        }

        drag(event) {
          if (!this.draggedPoint) return;

          const { x, y } = this.getMousePosition(event);

          // Find if this point belongs to an arc segment
          const arcSegment = this.segments.find(
            (s) =>
              s.type === "arc" &&
              s.points.some((p) => p.id === this.draggedPoint.id)
          );

          if (arcSegment && arcSegment.circle) {
            // Constrain movement to the fixed circle
            this.draggedPoint.constrainToCircle(arcSegment.circle, x, y);
          } else {
            // Free movement for line points or unconnected points
            this.draggedPoint.x = x - this.offset.x;
            this.draggedPoint.y = y - this.offset.y;
          }

          this.redraw();
        }

        stopDrag() {
          this.draggedPoint = null;
        }

        redraw() {
          this.svg.innerHTML = "";
          this.segments.forEach((segment) => segment.draw(this.svg));
          this.allPoints.forEach((point) => {
            const element = point.draw(this.svg);
            element.addEventListener("mousedown", (e) => this.startDrag(e));
          });
          this.tempPoints.forEach((point) => {
            const element = point.draw(this.svg);
            element.addEventListener("mousedown", (e) => this.startDrag(e));
          });
        }

        setupEventListeners() {
          this.svg.addEventListener("click", (e) => this.handleClick(e));
          document.addEventListener("mousemove", (e) => this.drag(e));
          document.addEventListener("mouseup", () => this.stopDrag());

          document
            .getElementById("toggleMode")
            .addEventListener("click", () => {
              CanvasManager.currentMode =
                CanvasManager.currentMode === "arc" ? "line" : "arc";
              document.getElementById("toggleMode").textContent = `Switch to ${
                CanvasManager.currentMode === "arc" ? "Line" : "Arc"
              } Mode`;
              this.tempPoints = [];
              this.redraw();
            });

          document.getElementById("clearLast").addEventListener("click", () => {
            if (!this.segments.length) return;
            this.segments.pop();
            const usedIds = new Set();
            this.segments.forEach((s) =>
              s.points.forEach((p) => usedIds.add(p.id))
            );
            this.tempPoints.forEach((p) => usedIds.add(p.id));
            this.allPoints = this.allPoints.filter((p) => usedIds.has(p.id));
            this.redraw();
          });

          document.getElementById("clearAll").addEventListener("click", () => {
            this.segments = [];
            this.allPoints = [];
            this.tempPoints = [];
            this.currentLabelCharCode = 65;
            document.getElementById("nextLabel").value = "A";
            this.redraw();
          });

          document
            .getElementById("pointSize")
            .addEventListener("input", (e) => {
              CanvasManager.POINT_RADIUS = parseInt(e.target.value);
              this.redraw();
            });

          document
            .getElementById("nextLabel")
            .addEventListener("input", (e) => {
              const val = e.target.value.toUpperCase();
              if (val.length === 1 && val.match(/[A-Z]/i)) {
                this.currentLabelCharCode = val.charCodeAt(0);
              }
            });
        }
      }

      const manager = new CanvasManager();
    </script>
  </body>
</html>
