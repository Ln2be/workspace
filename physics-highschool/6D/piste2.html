<!DOCTYPE html>
<html>
  <head>
    <title>Complete Segment Generator</title>
    <style>
      #svg {
        border: 1px solid #000;
      }
      button {
        margin: 10px;
        padding: 5px 15px;
      }
      .controls {
        margin: 10px;
      }
      .point:hover {
        cursor: move;
        filter: brightness(120%);
      }
      .point-label {
        font-family: Arial;
        font-size: 12px;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <button id="toggleMode">Switch to Line Mode</button>
      <button id="clearLast">Clear Last Segment</button>
      <button id="clearAll">Clear All</button>
      <label>Point Size: </label>
      <input type="range" id="pointSize" min="3" max="20" value="7" />
      <label>Label: </label>
      <input type="text" id="nextLabel" size="1" value="A" />
    </div>
    <svg id="svg" width="800" height="600"></svg>

    <script>
      let POINT_RADIUS = 7;
      const SNAP_DISTANCE = 15;
      let currentLabelCharCode = 65;

      let segments = [];
      let currentMode = "arc";
      let tempPoints = [];
      let allPoints = [];
      let draggedPoint = null;
      let offset = { x: 0, y: 0 };

      function getMousePosition(event) {
        const rect = document.getElementById("svg").getBoundingClientRect();
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
        };
      }

      function getNextLabel() {
        const label = String.fromCharCode(currentLabelCharCode);
        currentLabelCharCode =
          currentLabelCharCode < 90 ? currentLabelCharCode + 1 : 65;
        return label;
      }

      function updateLabelInput() {
        document.getElementById("nextLabel").value =
          String.fromCharCode(currentLabelCharCode);
      }

      function findExistingPoint(x, y) {
        return allPoints.find(
          (p) => Math.hypot(p.x - x, p.y - y) <= SNAP_DISTANCE
        );
      }

      function handleClick(event) {
        if (draggedPoint) return;

        const { x, y } = getMousePosition(event);
        const existing = findExistingPoint(x, y);

        if (existing) {
          tempPoints.push(existing);
        } else {
          const newPoint = {
            x,
            y,
            id: Date.now() + Math.random(),
            label: document.getElementById("nextLabel").value,
            size: POINT_RADIUS,
          };
          allPoints.push(newPoint);
          tempPoints.push(newPoint);
          currentLabelCharCode = newPoint.label.charCodeAt(0) + 1;
          if (currentLabelCharCode > 90) currentLabelCharCode = 65;
          updateLabelInput();
        }

        if (
          (currentMode === "arc" && tempPoints.length === 3) ||
          (currentMode === "line" && tempPoints.length === 2)
        ) {
          completeSegment();
        }

        redrawCanvas();
      }

      function completeSegment() {
        if (currentMode === "arc") {
          const circle = calculateCircle(...tempPoints);
          if (!circle) {
            alert("Points are collinear!");
            tempPoints = [];
            return;
          }
          segments.push({
            type: "arc",
            points: [...tempPoints],
            circle: circle,
          });
        } else {
          segments.push({
            type: "line",
            points: [...tempPoints],
          });
        }
        tempPoints = [];
      }

      function startDrag(event) {
        const pointId = event.target.getAttribute("data-point-id");
        draggedPoint = allPoints.find((p) => p.id == pointId);

        if (!draggedPoint) return;

        const rect = document.getElementById("svg").getBoundingClientRect();
        offset.x = event.clientX - rect.left - draggedPoint.x;
        offset.y = event.clientY - rect.top - draggedPoint.y;

        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", stopDrag);
      }

      function drag(event) {
        if (!draggedPoint) return;

        const rect = document.getElementById("svg").getBoundingClientRect();
        draggedPoint.x = event.clientX - rect.left - offset.x;
        draggedPoint.y = event.clientY - rect.top - offset.y;

        redrawCanvas();
      }

      function stopDrag() {
        draggedPoint = null;
        document.removeEventListener("mousemove", drag);
        document.removeEventListener("mouseup", stopDrag);
      }

      function calculateCircle(A, B, C) {
        const D =
          2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
        if (D === 0) return null;

        const cx =
          ((A.x ** 2 + A.y ** 2) * (B.y - C.y) +
            (B.x ** 2 + B.y ** 2) * (C.y - A.y) +
            (C.x ** 2 + C.y ** 2) * (A.y - B.y)) /
          D;

        const cy =
          ((A.x ** 2 + A.y ** 2) * (C.x - B.x) +
            (B.x ** 2 + B.y ** 2) * (A.x - C.x) +
            (C.x ** 2 + C.y ** 2) * (B.x - A.x)) /
          D;

        return {
          cx: cx,
          cy: cy,
          radius: Math.hypot(A.x - cx, A.y - cy),
        };
      }

      function createArcPath(circle, left, middle, right) {
        const thetaL = calculateAngle(left, circle.cx, circle.cy);
        const thetaM = calculateAngle(middle, circle.cx, circle.cy);
        const thetaR = calculateAngle(right, circle.cx, circle.cy);

        const sweepFlag = isMiddleInClockwise(thetaL, thetaR, thetaM) ? 1 : 0;
        const angle = sweepFlag
          ? (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI)
          : (thetaL - thetaR + 2 * Math.PI) % (2 * Math.PI);
        const largeArcFlag = angle > Math.PI ? 1 : 0;

        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute(
          "d",
          `M ${left.x},${left.y} ` +
            `A ${circle.radius} ${circle.radius} 0 ` +
            `${largeArcFlag} ${sweepFlag} ${right.x},${right.y}`
        );
        path.setAttribute("stroke", "blue");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-width", "2");
        return path;
      }

      function calculateAngle(point, cx, cy) {
        const dx = point.x - cx;
        const dy = point.y - cy;
        const angle = Math.atan2(dy, dx);
        return angle < 0 ? angle + 2 * Math.PI : angle;
      }

      function isMiddleInClockwise(thetaL, thetaR, thetaM) {
        return (
          (thetaM - thetaL + 2 * Math.PI) % (2 * Math.PI) <=
          (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI)
        );
      }

      function drawPointElement(point) {
        const element = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        element.setAttribute("data-point-id", point.id);
        element.setAttribute("cx", point.x);
        element.setAttribute("cy", point.y);
        element.setAttribute("r", POINT_RADIUS);
        element.setAttribute("fill", currentMode === "arc" ? "red" : "green");
        element.setAttribute("class", "point");
        element.addEventListener("mousedown", startDrag);

        const label = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        label.setAttribute("x", point.x + POINT_RADIUS + 2);
        label.setAttribute("y", point.y - POINT_RADIUS - 2);
        label.setAttribute("class", "point-label");
        label.textContent = point.label;

        return [element, label];
      }

      function redrawCanvas() {
        const svg = document.getElementById("svg");
        svg.innerHTML = "";

        segments.forEach((segment) => {
          if (segment.type === "arc") {
            const circle = calculateCircle(...segment.points);
            if (circle) {
              const sorted = [...segment.points].sort((a, b) => a.x - b.x);
              const path = createArcPath(
                circle,
                sorted[0],
                sorted[1],
                sorted[2]
              );
              svg.appendChild(path);

              const center = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              center.setAttribute("cx", circle.cx);
              center.setAttribute("cy", circle.cy);
              center.setAttribute("r", POINT_RADIUS);
              center.setAttribute("fill", "blue");
              svg.appendChild(center);

              const centerLabel = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              centerLabel.setAttribute("x", circle.cx + POINT_RADIUS + 2);
              centerLabel.setAttribute("y", circle.cy - POINT_RADIUS - 2);
              centerLabel.textContent = "C" + segment.points[0].label;
              svg.appendChild(centerLabel);
            }
          } else {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            line.setAttribute("x1", segment.points[0].x);
            line.setAttribute("y1", segment.points[0].y);
            line.setAttribute("x2", segment.points[1].x);
            line.setAttribute("y2", segment.points[1].y);
            line.setAttribute("stroke", "green");
            line.setAttribute("stroke-width", "2");
            svg.appendChild(line);
          }
        });

        allPoints.forEach((p) => {
          const [pointElement, labelElement] = drawPointElement(p);
          svg.appendChild(pointElement);
          svg.appendChild(labelElement);
        });
        tempPoints.forEach((p) => {
          const [pointElement, labelElement] = drawPointElement(p);
          svg.appendChild(pointElement);
          svg.appendChild(labelElement);
        });
      }

      document.getElementById("svg").addEventListener("click", handleClick);
      document.getElementById("toggleMode").addEventListener("click", () => {
        currentMode = currentMode === "arc" ? "line" : "arc";
        document.getElementById("toggleMode").textContent = `Switch to ${
          currentMode === "arc" ? "Line" : "Arc"
        } Mode`;
        tempPoints = [];
        redrawCanvas();
      });

      document.getElementById("clearLast").addEventListener("click", () => {
        if (segments.length === 0) return;
        const removed = segments.pop();

        const usedIds = new Set();
        segments.forEach((s) => s.points.forEach((p) => usedIds.add(p.id)));
        tempPoints.forEach((p) => usedIds.add(p.id));

        allPoints = allPoints.filter((p) => usedIds.has(p.id));
        redrawCanvas();
      });

      document.getElementById("clearAll").addEventListener("click", () => {
        segments = [];
        allPoints = [];
        tempPoints = [];
        currentLabelCharCode = 65;
        updateLabelInput();
        redrawCanvas();
      });

      document.getElementById("pointSize").addEventListener("input", (e) => {
        POINT_RADIUS = parseInt(e.target.value);
        redrawCanvas();
      });

      document.getElementById("nextLabel").addEventListener("input", (e) => {
        const val = e.target.value.toUpperCase();
        if (val.length === 1 && val.match(/[A-Z]/i)) {
          currentLabelCharCode = val.charCodeAt(0);
          updateLabelInput();
        }
      });

      updateLabelInput();
      redrawCanvas();
    </script>
  </body>
</html>
