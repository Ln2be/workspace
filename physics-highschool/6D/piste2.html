<!DOCTYPE html>
<html>
  <head>
    <title>Segment Generator with Point Reuse</title>
    <style>
      #svg {
        border: 1px solid #000;
      }
      button {
        margin: 10px;
        padding: 5px 15px;
      }
      .point:hover {
        filter: brightness(150%);
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <button id="toggleMode">Switch to Line Mode</button>
    <button id="clearAll">Clear All</button>
    <svg id="svg" width="800" height="600"></svg>

    <script>
      const POINT_RADIUS = 5;
      const SNAP_DISTANCE = 10;

      let segments = [];
      let currentMode = "arc";
      let tempPoints = [];
      let allPoints = [];

      function handleClick(event) {
        const { x, y } = getMousePosition(event);
        const existing = findExistingPoint(x, y);

        if (existing) {
          handleExistingPoint(existing);
        } else {
          handleNewPoint(x, y);
        }

        redrawCanvas();
      }

      function handleExistingPoint(point) {
        tempPoints.push(point);
        if (shouldCompleteSegment()) {
          completeSegment();
        }
      }

      function handleNewPoint(x, y) {
        const newPoint = { x, y, id: Date.now() + Math.random() };
        allPoints.push(newPoint);
        tempPoints.push(newPoint);

        if (shouldCompleteSegment()) {
          completeSegment();
        }
      }

      function shouldCompleteSegment() {
        return (
          (currentMode === "arc" && tempPoints.length === 3) ||
          (currentMode === "line" && tempPoints.length === 2)
        );
      }

      function completeSegment() {
        if (currentMode === "arc") {
          const circle = calculateCircle(...tempPoints);
          if (!circle) {
            alert("Points are collinear!");
            tempPoints = [];
            return;
          }
          segments.push({
            type: "arc",
            points: [...tempPoints],
            circle: circle,
          });
        } else {
          segments.push({
            type: "line",
            points: [...tempPoints],
          });
        }
        tempPoints = [];
      }

      function findExistingPoint(x, y) {
        return allPoints.find(
          (p) => Math.hypot(p.x - x, p.y - y) <= SNAP_DISTANCE
        );
      }

      function redrawCanvas() {
        clearCanvas();

        // Draw all segments
        segments.forEach((segment) => {
          if (segment.type === "arc") {
            drawArcSegment(segment);
          } else {
            drawLineSegment(segment);
          }
        });

        // Draw temporary points
        tempPoints.forEach((p) => drawPointElement(p));

        // Draw all existing points
        allPoints.forEach((p) => drawPointElement(p));
      }

      function drawArcSegment(segment) {
        // Draw reference circle
        const circle = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        circle.setAttribute("cx", segment.circle.cx);
        circle.setAttribute("cy", segment.circle.cy);
        circle.setAttribute("r", segment.circle.radius);
        circle.setAttribute("stroke", "#cccccc");
        circle.setAttribute("fill", "none");
        document.getElementById("svg").appendChild(circle);

        // Draw arc
        const sorted = [...segment.points].sort((a, b) => a.x - b.x);
        const path = createArcPath(
          segment.circle,
          sorted[0],
          sorted[1],
          sorted[2]
        );
        document.getElementById("svg").appendChild(path);
      }

      function drawLineSegment(segment) {
        const line = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        line.setAttribute("x1", segment.points[0].x);
        line.setAttribute("y1", segment.points[0].y);
        line.setAttribute("x2", segment.points[1].x);
        line.setAttribute("y2", segment.points[1].y);
        line.setAttribute("stroke", "green");
        line.setAttribute("stroke-width", "2");
        document.getElementById("svg").appendChild(line);
      }

      function drawPointElement(point) {
        const element = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        element.setAttribute("class", "point");
        element.setAttribute("cx", point.x);
        element.setAttribute("cy", point.y);
        element.setAttribute("r", POINT_RADIUS);
        element.setAttribute("fill", currentMode === "arc" ? "red" : "green");
        document.getElementById("svg").appendChild(element);
      }

      // Circle calculation functions
      function calculateCircle(A, B, C) {
        const D =
          2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
        if (D === 0) return null;

        const cx =
          ((A.x ** 2 + A.y ** 2) * (B.y - C.y) +
            (B.x ** 2 + B.y ** 2) * (C.y - A.y) +
            (C.x ** 2 + C.y ** 2) * (A.y - B.y)) /
          D;

        const cy =
          ((A.x ** 2 + A.y ** 2) * (C.x - B.x) +
            (B.x ** 2 + B.y ** 2) * (A.x - C.x) +
            (C.x ** 2 + C.y ** 2) * (B.x - A.x)) /
          D;

        return {
          cx: cx,
          cy: cy,
          radius: Math.hypot(A.x - cx, A.y - cy),
        };
      }

      function createArcPath(circle, left, middle, right) {
        const thetaL = calculateAngle(left, circle.cx, circle.cy);
        const thetaM = calculateAngle(middle, circle.cx, circle.cy);
        const thetaR = calculateAngle(right, circle.cx, circle.cy);

        const sweepFlag = isMiddleInClockwise(thetaL, thetaR, thetaM) ? 1 : 0;
        const angle = sweepFlag
          ? (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI)
          : (thetaL - thetaR + 2 * Math.PI) % (2 * Math.PI);
        const largeArcFlag = angle > Math.PI ? 1 : 0;

        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute(
          "d",
          `M ${left.x},${left.y} ` +
            `A ${circle.radius} ${circle.radius} 0 ` +
            `${largeArcFlag} ${sweepFlag} ${right.x},${right.y}`
        );
        path.setAttribute("stroke", "blue");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-width", "2");
        return path;
      }

      function calculateAngle(point, cx, cy) {
        const dx = point.x - cx;
        const dy = point.y - cy;
        const angle = Math.atan2(dy, dx);
        return angle < 0 ? angle + 2 * Math.PI : angle;
      }

      function isMiddleInClockwise(thetaL, thetaR, thetaM) {
        return (
          (thetaM - thetaL + 2 * Math.PI) % (2 * Math.PI) <=
          (thetaR - thetaL + 2 * Math.PI) % (2 * Math.PI)
        );
      }

      // Helper functions
      function getMousePosition(event) {
        const rect = document.getElementById("svg").getBoundingClientRect();
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
        };
      }

      function clearCanvas() {
        const svg = document.getElementById("svg");
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
      }

      // Event listeners
      document.getElementById("svg").addEventListener("click", handleClick);
      document.getElementById("toggleMode").addEventListener("click", () => {
        currentMode = currentMode === "arc" ? "line" : "arc";
        document.getElementById("toggleMode").textContent = `Switch to ${
          currentMode === "arc" ? "Line" : "Arc"
        } Mode`;
        tempPoints = [];
        redrawCanvas();
      });
      document.getElementById("clearAll").addEventListener("click", () => {
        segments = [];
        allPoints = [];
        tempPoints = [];
        redrawCanvas();
      });
    </script>
  </body>
</html>
